<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>トーンカーブエディタ</title>
<style>
  body {
    font-family: 'Helvetica Neue', Arial, sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f5f5f5;
    color: #333;
  }
  .container {
    max-width: 1200px;
    margin: 0 auto;
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  h1 {
    text-align: center;
    margin-bottom: 20px;
    color: #2c3e50;
  }
  .dropzone {
    border: 3px dashed #ccc;
    border-radius: 8px;
    padding: 30px;
    text-align: center;
    transition: all 0.3s;
    margin-bottom: 20px;
    background-color: #f9f9f9;
  }
  .dropzone.active {
    border-color: #3498db;
    background-color: rgba(52, 152, 219, 0.1);
  }
  .dropzone p {
    font-size: 18px;
    color: #7f8c8d;
  }
  .editor {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
  }
  .preview-container, .curve-container {
    flex: 1;
    min-width: 300px;
  }
  canvas {
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  #tone-curve {
    background-color: #f8f8f8;
  }
  .button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
    transition: background-color 0.2s;
  }
  .button:hover {
    background-color: #2980b9;
  }
  .button:disabled {
    background-color: #bdc3c7;
    cursor: not-allowed;
  }
  .hidden {
    display: none;
  }
  .instructions {
    background-color: #f7f9fa;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 20px;
    border-left: 4px solid #3498db;
  }
  .instructions h3 {
    margin-top: 0;
    color: #2c3e50;
  }
  .instructions p {
    margin-bottom: 8px;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>トーンカーブエディタ</h1>
    
    <div class="instructions">
      <h3>使い方</h3>
      <p>1. 画像をドラッグ＆ドロップするか「画像を選択」ボタンをクリックしてアップロード</p>
      <p>2. トーンカーブをクリックして制御点を追加し、ドラッグして調整</p>
      <p>3. 編集後の画像をダウンロード</p>
    </div>
    
    <div id="dropzone" class="dropzone">
      <p>ここに画像をドラッグ＆ドロップ</p>
      <p>または</p>
      <input type="file" id="file-input" accept="image/*" class="hidden">
      <button id="select-button" class="button">画像を選択</button>
    </div>
    
    <div id="editor" class="editor hidden">
      <div class="curve-container">
        <h3>トーンカーブ</h3>
        <canvas id="tone-curve" width="400" height="400"></canvas>
        <p>クリックして制御点を追加、ドラッグして調整</p>
        <button id="reset-button" class="button">リセット</button>
      </div>
      
      <div class="preview-container">
        <h3>プレビュー</h3>
        <canvas id="preview" width="400" height="400"></canvas>
        <div>
          <button id="download-button" class="button">画像をダウンロード</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // DOM要素
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('file-input');
      const selectButton = document.getElementById('select-button');
      const editorContainer = document.getElementById('editor');
      const toneCurveCanvas = document.getElementById('tone-curve');
      const previewCanvas = document.getElementById('preview');
      const resetButton = document.getElementById('reset-button');
      const downloadButton = document.getElementById('download-button');
      
      // コンテキスト
      const toneCurveCtx = toneCurveCanvas.getContext('2d');
      const previewCtx = previewCanvas.getContext('2d');
      
      // トーンカーブのパラメータ
      let points = [
        { x: 0, y: 0 },    // 左下
        { x: 1, y: 1 }     // 右上
      ];
      let selectedPoint = null;
      let originalImage = null;
      let processedImage = null;
      let originalFileName = "image"; // 元のファイル名
      let originalImgElement = null; // 元の画像要素
      
      // イベントリスナー
      dropzone.addEventListener('dragover', handleDragOver);
      dropzone.addEventListener('dragleave', handleDragLeave);
      dropzone.addEventListener('drop', handleDrop);
      selectButton.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);
      toneCurveCanvas.addEventListener('mousedown', handleCanvasMouseDown);
      toneCurveCanvas.addEventListener('mousemove', handleCanvasMouseMove);
      toneCurveCanvas.addEventListener('mouseup', () => { selectedPoint = null; });
      toneCurveCanvas.addEventListener('mouseleave', () => { selectedPoint = null; });
      resetButton.addEventListener('click', resetCurve);
      downloadButton.addEventListener('click', downloadImage);
      
      // ドラッグ＆ドロップ処理
      function handleDragOver(e) {
        e.preventDefault();
        dropzone.classList.add('active');
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        dropzone.classList.remove('active');
      }
      
      function handleDrop(e) {
        e.preventDefault();
        dropzone.classList.remove('active');
        
        if (e.dataTransfer.files.length) {
          processFile(e.dataTransfer.files[0]);
        }
      }
      
      function handleFileSelect(e) {
        if (e.target.files.length) {
          processFile(e.target.files[0]);
        }
      }
      
      // ファイル処理
      function processFile(file) {
        if (!file.type.match('image.*')) {
          alert('画像ファイルを選択してください。');
          return;
        }
        
        // ファイル名を保存（拡張子を除く）
        originalFileName = file.name.replace(/\.[^/.]+$/, "");
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            // 元の画像要素を保存
            originalImgElement = img;
            
            // 画像のアスペクト比を保ちながらキャンバスに合わせる
            const scale = Math.min(
              previewCanvas.width / img.width,
              previewCanvas.height / img.height
            );
            
            const newWidth = img.width * scale;
            const newHeight = img.height * scale;
            
            // キャンバスをクリア
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // 中央に配置
            const offsetX = (previewCanvas.width - newWidth) / 2;
            const offsetY = (previewCanvas.height - newHeight) / 2;
            
            previewCtx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
            
            // 元画像データを保存
            originalImage = {
              data: previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height),
              width: newWidth,
              height: newHeight,
              offsetX: offsetX,
              offsetY: offsetY,
              originalWidth: img.width,
              originalHeight: img.height
            };
            
            // エディタを表示
            editorContainer.classList.remove('hidden');
            
            // 初期トーンカーブを描画
            drawToneCurve();
            
            // 画像に適用
            applyToneCurve();
          };
          
          img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
      }
      
      // トーンカーブ描画
      function drawToneCurve() {
        const width = toneCurveCanvas.width;
        const height = toneCurveCanvas.height;
        
        // キャンバスをクリア
        toneCurveCtx.clearRect(0, 0, width, height);
        
        // 背景グリッド
        toneCurveCtx.strokeStyle = '#e0e0e0';
        toneCurveCtx.lineWidth = 1;
        
        // 縦線と横線
        for (let i = 0; i <= 10; i++) {
          const pos = i * width / 10;
          
          // 縦線
          toneCurveCtx.beginPath();
          toneCurveCtx.moveTo(pos, 0);
          toneCurveCtx.lineTo(pos, height);
          toneCurveCtx.stroke();
          
          // 横線
          toneCurveCtx.beginPath();
          toneCurveCtx.moveTo(0, pos);
          toneCurveCtx.lineTo(width, pos);
          toneCurveCtx.stroke();
        }
        
        // 対角線（直線）
        toneCurveCtx.strokeStyle = '#aaa';
        toneCurveCtx.beginPath();
        toneCurveCtx.moveTo(0, height);
        toneCurveCtx.lineTo(width, 0);
        toneCurveCtx.stroke();
        
        // ポイントをソート
        points.sort((a, b) => a.x - b.x);
        
        // スプラインカーブを描画
        drawBezierCurve();
        
        // 制御点の描画
        points.forEach(point => {
          toneCurveCtx.fillStyle = '#2980b9';
          toneCurveCtx.beginPath();
          toneCurveCtx.arc(
            point.x * width,
            (1 - point.y) * height,
            6, 0, Math.PI * 2
          );
          toneCurveCtx.fill();
          
          toneCurveCtx.strokeStyle = 'white';
          toneCurveCtx.lineWidth = 2;
          toneCurveCtx.stroke();
        });
      }
      
      // なだらかなベジェ曲線の描画
      function drawBezierCurve() {
        const width = toneCurveCanvas.width;
        const height = toneCurveCanvas.height;
        
        if (points.length < 2) return;
        
        toneCurveCtx.strokeStyle = '#3498db';
        toneCurveCtx.lineWidth = 2;
        
        toneCurveCtx.beginPath();
        toneCurveCtx.moveTo(
          points[0].x * width,
          (1 - points[0].y) * height
        );
        
        if (points.length === 2) {
          // 2点の場合は直線
          toneCurveCtx.lineTo(
            points[1].x * width,
            (1 - points[1].y) * height
          );
        } else {
          // 3点以上の場合はなだらかなベジェ曲線
          for (let i = 0; i < points.length - 1; i++) {
            // 現在の点と次の点
            const p0 = points[i];
            const p1 = points[i + 1];
            
            // 中間のコントロールポイントを計算
            let cp1x, cp1y, cp2x, cp2y;
            
            if (i === 0) {
              // 最初のセグメント
              const dx = p1.x - p0.x;
              cp1x = p0.x + dx / 3;
              cp1y = p0.y + (p1.y - p0.y) / 3;
              cp2x = p0.x + 2 * dx / 3;
              cp2y = p0.y + 2 * (p1.y - p0.y) / 3;
            } else if (i === points.length - 2) {
              // 最後のセグメント
              const dx = p1.x - p0.x;
              cp1x = p0.x + dx / 3;
              cp1y = p0.y + (p1.y - p0.y) / 3;
              cp2x = p0.x + 2 * dx / 3;
              cp2y = p0.y + 2 * (p1.y - p0.y) / 3;
            } else {
              // 中間のセグメント
              const prev = points[i - 1];
              const next = points[i + 2] || p1;
              
              // カーブの接線方向を計算して自然なカーブに
              const tension = 0.4; // テンション係数（0?1）
              
              // 前後の点を使って接線の方向を計算
              const tdx = (next.x - prev.x) * tension;
              const tdy = (next.y - prev.y) * tension;
              
              cp1x = p0.x + tdx / 3;
              cp1y = p0.y + tdy / 3;
              
              cp2x = p1.x - tdx / 3;
              cp2y = p1.y - tdy / 3;
            }
            
            // カーブを描画
            toneCurveCtx.bezierCurveTo(
              cp1x * width, (1 - cp1y) * height,
              cp2x * width, (1 - cp2y) * height,
              p1.x * width, (1 - p1.y) * height
            );
          }
        }
        
        toneCurveCtx.stroke();
      }
      
      // トーンカーブの適用
      function applyToneCurve() {
        if (!originalImage) return;
        
        // ルックアップテーブルの作成
        const lookupTable = new Uint8Array(256);
        
        // 各輝度値について対応する出力値を計算
        for (let i = 0; i < 256; i++) {
          const normalizedValue = i / 255;
          
          // スプライン補間でカーブ上の値を計算
          let mappedValue = evaluateCurve(normalizedValue);
          
          lookupTable[i] = Math.max(0, Math.min(255, Math.round(mappedValue * 255)));
        }
        
        // 画像データを取得
        const imageData = new ImageData(
          new Uint8ClampedArray(originalImage.data.data),
          originalImage.data.width,
          originalImage.data.height
        );
        
        // 各ピクセルにトーンカーブを適用
        for (let i = 0; i < imageData.data.length; i += 4) {
          // RGBチャンネルに適用（アルファチャンネルはそのまま）
          imageData.data[i] = lookupTable[imageData.data[i]];
          imageData.data[i+1] = lookupTable[imageData.data[i+1]];
          imageData.data[i+2] = lookupTable[imageData.data[i+2]];
        }
        
        // 画像を描画
        previewCtx.putImageData(imageData, 0, 0);
        
        // 処理後の画像を保存
        processedImage = imageData;
      }
      
      // スプライン補間でカーブの値を評価
      function evaluateCurve(x) {
        if (points.length < 2) return x;
        
        // x座標に対応するセグメントを見つける
        let segmentIndex = 0;
        for (let i = 0; i < points.length - 1; i++) {
          if (x >= points[i].x && x <= points[i + 1].x) {
            segmentIndex = i;
            break;
          }
        }
        
        const p0 = points[segmentIndex];
        const p1 = points[segmentIndex + 1];
        
        // セグメント内での相対位置を計算
        const t = (x - p0.x) / (p1.x - p0.x);
        
        if (points.length === 2) {
          // 2点の場合は線形補間
          return p0.y + t * (p1.y - p0.y);
        } else {
          // 3点以上の場合はキュービック補間
          // エルミート補間を使用
          const h00 = 2*t*t*t - 3*t*t + 1;
          const h10 = t*t*t - 2*t*t + t;
          const h01 = -2*t*t*t + 3*t*t;
          const h11 = t*t*t - t*t;
          
          let m0, m1; // 接線
          
          if (segmentIndex === 0) {
            // 最初のセグメント
            m0 = (p1.y - p0.y) / (p1.x - p0.x);
            m1 = m0;
          } else if (segmentIndex === points.length - 2) {
            // 最後のセグメント
            m0 = (p1.y - p0.y) / (p1.x - p0.x);
            m1 = m0;
          } else {
            // 中間のセグメント
            const prev = points[segmentIndex - 1];
            const next = points[segmentIndex + 2] || p1;
            
            // キャットマルロム法で接線を計算
            const tension = 0.5; // テンション係数
            
            m0 = tension * (p1.y - prev.y) / (p1.x - prev.x);
            m1 = tension * (next.y - p0.y) / (next.x - p0.x);
          }
          
          // スケール調整（x軸の間隔に合わせる）
          m0 *= (p1.x - p0.x);
          m1 *= (p1.x - p0.x);
          
          // エルミート補間
          return h00 * p0.y + h10 * m0 + h01 * p1.y + h11 * m1;
        }
      }
      
      // マウスイベント処理
      function handleCanvasMouseDown(e) {
        const rect = toneCurveCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / toneCurveCanvas.width;
        const y = 1 - (e.clientY - rect.top) / toneCurveCanvas.height;
        
        // 既存の点をクリックしたか確認
        let pointClicked = false;
        
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          const distance = Math.sqrt(
            Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
          );
          
          if (distance < 0.03) {
            selectedPoint = point;
            pointClicked = true;
            break;
          }
        }
        
        // 固定点（左下と右上）は動かせない
        if (selectedPoint === points[0] && points[0].x === 0 && points[0].y === 0) {
          selectedPoint = null;
          return;
        }
        
        if (selectedPoint === points[points.length - 1] && 
            points[points.length - 1].x === 1 && points[points.length - 1].y === 1) {
          selectedPoint = null;
          return;
        }
        
        // 新しい点を追加
        if (!pointClicked) {
          const newPoint = { x: x, y: y };
          points.push(newPoint);
          selectedPoint = newPoint;
          
          // ポイントをx座標でソート
          points.sort((a, b) => a.x - b.x);
        }
        
        drawToneCurve();
        applyToneCurve();
      }
      
      function handleCanvasMouseMove(e) {
        if (!selectedPoint) return;
        
        const rect = toneCurveCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / toneCurveCanvas.width;
        const y = 1 - (e.clientY - rect.top) / toneCurveCanvas.height;
        
        // 左右の境界を超えないようにする
        selectedPoint.x = Math.max(0, Math.min(1, x));
        selectedPoint.y = Math.max(0, Math.min(1, y));
        
        drawToneCurve();
        applyToneCurve();
      }
      
      // トーンカーブのリセット
      function resetCurve() {
        points = [
          { x: 0, y: 0 },
          { x: 1, y: 1 }
        ];
        
        drawToneCurve();
        applyToneCurve();
      }
      
      // 画像のダウンロード
      function downloadImage() {
        if (!originalImgElement || !processedImage) return;
        
        // 元の画像と同じサイズのキャンバスを作成
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = originalImgElement.width;
        tempCanvas.height = originalImgElement.height;
        const tempCtx = tempCanvas.getContext('2d');
        
        // 元の画像を描画
        tempCtx.drawImage(originalImgElement, 0, 0);
        
        // 元の画像データを取得
        const originalData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
        
        // トーンカーブの変換テーブルを作成
        const lookupTable = new Uint8Array(256);
        for (let i = 0; i < 256; i++) {
          const normalizedValue = i / 255;
          let mappedValue = evaluateCurve(normalizedValue);
          lookupTable[i] = Math.max(0, Math.min(255, Math.round(mappedValue * 255)));
        }
        
        // 元のサイズの画像にトーンカーブを適用
        for (let i = 0; i < originalData.data.length; i += 4) {
          originalData.data[i] = lookupTable[originalData.data[i]];
          originalData.data[i+1] = lookupTable[originalData.data[i+1]];
          originalData.data[i+2] = lookupTable[originalData.data[i+2]];
        }
        
        // 変換後の画像データを描画
        tempCtx.putImageData(originalData, 0, 0);
        
        // ダウンロードリンクを作成
        const link = document.createElement('a');
        link.download = originalFileName + "_tonecurve.png";
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      }
      
      // 初期トーンカーブを描画
      drawToneCurve();
    });
  </script>
</body>
</html>