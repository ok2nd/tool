<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>トーンカーブエディタ</title>
<style>
  body {
    font-family: 'Helvetica Neue', Arial, sans-serif;
    margin: 0;
    padding: 20px;
    background-color: #f5f5f5;
    color: #333;
  }
  .container {
    max-width: 1200px;
    margin: 0 auto;
    background-color: white;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
  }
  h1 {
    text-align: center;
    margin-bottom: 20px;
    color: #2c3e50;
  }
  .dropzone {
    border: 3px dashed #ccc;
    border-radius: 8px;
    padding: 30px;
    text-align: center;
    transition: all 0.3s;
    margin-bottom: 20px;
    background-color: #f9f9f9;
  }
  .dropzone.active {
    border-color: #3498db;
    background-color: rgba(52, 152, 219, 0.1);
  }
  .dropzone p {
    font-size: 18px;
    color: #7f8c8d;
  }
  .editor {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    margin-top: 20px;
  }
  .preview-container, .curve-container {
    flex: 1;
    min-width: 300px;
  }
  canvas {
    background-color: white;
    border: 1px solid #ddd;
    border-radius: 4px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
  }
  #tone-curve {
    background-color: #f8f8f8;
  }
  .button {
    background-color: #3498db;
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 16px;
    margin-top: 10px;
    transition: background-color 0.2s;
  }
  .button:hover {
    background-color: #2980b9;
  }
  .button:disabled {
    background-color: #bdc3c7;
    cursor: not-allowed;
  }
  .hidden {
    display: none;
  }
  .instructions {
    background-color: #f7f9fa;
    padding: 15px;
    border-radius: 5px;
    margin-bottom: 20px;
    border-left: 4px solid #3498db;
  }
  .instructions h3 {
    margin-top: 0;
    color: #2c3e50;
  }
  .instructions p {
    margin-bottom: 8px;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>トーンカーブエディタ</h1>
    
    <div class="instructions">
      <h3>使い方</h3>
      <p>1. 画像をドラッグ＆ドロップするか「画像を選択」ボタンをクリックしてアップロード</p>
      <p>2. トーンカーブをクリックして制御点を追加し、ドラッグして調整</p>
      <p>3. 編集後の画像をダウンロード</p>
    </div>
    
    <div id="dropzone" class="dropzone">
      <p>ここに画像をドラッグ＆ドロップ</p>
      <p>または</p>
      <input type="file" id="file-input" accept="image/*" class="hidden">
      <button id="select-button" class="button">画像を選択</button>
    </div>
    
    <div id="editor" class="editor hidden">
      <div class="curve-container">
        <h3>トーンカーブ</h3>
        <canvas id="tone-curve" width="400" height="400"></canvas>
        <p>クリックして制御点を追加、ドラッグして調整</p>
        <button id="reset-button" class="button">リセット</button>
      </div>
      
      <div class="preview-container">
        <h3>プレビュー</h3>
        <canvas id="preview" width="400" height="400"></canvas>
        <div>
          <button id="download-button" class="button">画像をダウンロード</button>
        </div>
      </div>
    </div>
  </div>
  
  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // DOM要素
      const dropzone = document.getElementById('dropzone');
      const fileInput = document.getElementById('file-input');
      const selectButton = document.getElementById('select-button');
      const editorContainer = document.getElementById('editor');
      const toneCurveCanvas = document.getElementById('tone-curve');
      const previewCanvas = document.getElementById('preview');
      const resetButton = document.getElementById('reset-button');
      const downloadButton = document.getElementById('download-button');
      
      // コンテキスト
      const toneCurveCtx = toneCurveCanvas.getContext('2d');
      const previewCtx = previewCanvas.getContext('2d');
      
      // トーンカーブのパラメータ
      let points = [
        { x: 0, y: 0 },    // 左下
        { x: 1, y: 1 }     // 右上
      ];
      let selectedPoint = null;
      let originalImage = null;
      let processedImage = null;
      
      // イベントリスナー
      dropzone.addEventListener('dragover', handleDragOver);
      dropzone.addEventListener('dragleave', handleDragLeave);
      dropzone.addEventListener('drop', handleDrop);
      selectButton.addEventListener('click', () => fileInput.click());
      fileInput.addEventListener('change', handleFileSelect);
      toneCurveCanvas.addEventListener('mousedown', handleCanvasMouseDown);
      toneCurveCanvas.addEventListener('mousemove', handleCanvasMouseMove);
      toneCurveCanvas.addEventListener('mouseup', () => { selectedPoint = null; });
      toneCurveCanvas.addEventListener('mouseleave', () => { selectedPoint = null; });
      resetButton.addEventListener('click', resetCurve);
      downloadButton.addEventListener('click', downloadImage);
      
      // ドラッグ＆ドロップ処理
      function handleDragOver(e) {
        e.preventDefault();
        dropzone.classList.add('active');
      }
      
      function handleDragLeave(e) {
        e.preventDefault();
        dropzone.classList.remove('active');
      }
      
      function handleDrop(e) {
        e.preventDefault();
        dropzone.classList.remove('active');
        
        if (e.dataTransfer.files.length) {
          processFile(e.dataTransfer.files[0]);
        }
      }
      
      function handleFileSelect(e) {
        if (e.target.files.length) {
          processFile(e.target.files[0]);
        }
      }
      
      // ファイル処理
      function processFile(file) {
        if (!file.type.match('image.*')) {
          alert('画像ファイルを選択してください。');
          return;
        }
        
        const reader = new FileReader();
        
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            // 画像のアスペクト比を保ちながらキャンバスに合わせる
            const scale = Math.min(
              previewCanvas.width / img.width,
              previewCanvas.height / img.height
            );
            
            const newWidth = img.width * scale;
            const newHeight = img.height * scale;
            
            // キャンバスをクリア
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // 中央に配置
            const offsetX = (previewCanvas.width - newWidth) / 2;
            const offsetY = (previewCanvas.height - newHeight) / 2;
            
            previewCtx.drawImage(img, offsetX, offsetY, newWidth, newHeight);
            
            // 元画像データを保存
            originalImage = {
              data: previewCtx.getImageData(0, 0, previewCanvas.width, previewCanvas.height),
              width: newWidth,
              height: newHeight,
              offsetX: offsetX,
              offsetY: offsetY
            };
            
            // エディタを表示
            editorContainer.classList.remove('hidden');
            
            // 初期トーンカーブを描画
            drawToneCurve();
            
            // 画像に適用
            applyToneCurve();
          };
          
          img.src = e.target.result;
        };
        
        reader.readAsDataURL(file);
      }
      
      // トーンカーブ描画
      function drawToneCurve() {
        const width = toneCurveCanvas.width;
        const height = toneCurveCanvas.height;
        
        // キャンバスをクリア
        toneCurveCtx.clearRect(0, 0, width, height);
        
        // 背景グリッド
        toneCurveCtx.strokeStyle = '#e0e0e0';
        toneCurveCtx.lineWidth = 1;
        
        // 縦線と横線
        for (let i = 0; i <= 10; i++) {
          const pos = i * width / 10;
          
          // 縦線
          toneCurveCtx.beginPath();
          toneCurveCtx.moveTo(pos, 0);
          toneCurveCtx.lineTo(pos, height);
          toneCurveCtx.stroke();
          
          // 横線
          toneCurveCtx.beginPath();
          toneCurveCtx.moveTo(0, pos);
          toneCurveCtx.lineTo(width, pos);
          toneCurveCtx.stroke();
        }
        
        // 対角線（直線）
        toneCurveCtx.strokeStyle = '#aaa';
        toneCurveCtx.beginPath();
        toneCurveCtx.moveTo(0, height);
        toneCurveCtx.lineTo(width, 0);
        toneCurveCtx.stroke();
        
        // ポイントをソート
        points.sort((a, b) => a.x - b.x);
        
        // カーブを描画
        toneCurveCtx.strokeStyle = '#3498db';
        toneCurveCtx.lineWidth = 2;
        toneCurveCtx.beginPath();
        
        // スプライン曲線の描画
        if (points.length >= 2) {
          toneCurveCtx.moveTo(points[0].x * width, (1 - points[0].y) * height);
          
          for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i + 1];
            
            for (let t = 0; t <= 1; t += 0.05) {
              const x = linearInterpolation(p1.x, p2.x, t) * width;
              const y = (1 - linearInterpolation(p1.y, p2.y, t)) * height;
              toneCurveCtx.lineTo(x, y);
            }
          }
          
          toneCurveCtx.stroke();
        }
        
        // 制御点の描画
        points.forEach(point => {
          toneCurveCtx.fillStyle = '#2980b9';
          toneCurveCtx.beginPath();
          toneCurveCtx.arc(
            point.x * width,
            (1 - point.y) * height,
            6, 0, Math.PI * 2
          );
          toneCurveCtx.fill();
          
          toneCurveCtx.strokeStyle = 'white';
          toneCurveCtx.lineWidth = 2;
          toneCurveCtx.stroke();
        });
      }
      
      // 線形補間
      function linearInterpolation(a, b, t) {
        return a + (b - a) * t;
      }
      
      // トーンカーブの適用
      function applyToneCurve() {
        if (!originalImage) return;
        
        // ルックアップテーブルの作成
        const lookupTable = new Uint8Array(256);
        for (let i = 0; i < 256; i++) {
          const normalizedValue = i / 255;
          let mappedValue = normalizedValue;
          
          // ポイント間の補間
          for (let j = 0; j < points.length - 1; j++) {
            if (normalizedValue >= points[j].x && normalizedValue <= points[j+1].x) {
              const t = (normalizedValue - points[j].x) / (points[j+1].x - points[j].x);
              mappedValue = linearInterpolation(points[j].y, points[j+1].y, t);
              break;
            }
          }
          
          lookupTable[i] = Math.max(0, Math.min(255, Math.round(mappedValue * 255)));
        }
        
        // 画像データを取得
        const imageData = new ImageData(
          new Uint8ClampedArray(originalImage.data.data),
          originalImage.data.width,
          originalImage.data.height
        );
        
        // 各ピクセルにトーンカーブを適用
        for (let i = 0; i < imageData.data.length; i += 4) {
          // RGBチャンネルに適用（アルファチャンネルはそのまま）
          imageData.data[i] = lookupTable[imageData.data[i]];
          imageData.data[i+1] = lookupTable[imageData.data[i+1]];
          imageData.data[i+2] = lookupTable[imageData.data[i+2]];
        }
        
        // 画像を描画
        previewCtx.putImageData(imageData, 0, 0);
        
        // 処理後の画像を保存
        processedImage = imageData;
      }
      
      // マウスイベント処理
      function handleCanvasMouseDown(e) {
        const rect = toneCurveCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / toneCurveCanvas.width;
        const y = 1 - (e.clientY - rect.top) / toneCurveCanvas.height;
        
        // 既存の点をクリックしたか確認
        let pointClicked = false;
        
        for (let i = 0; i < points.length; i++) {
          const point = points[i];
          const distance = Math.sqrt(
            Math.pow(point.x - x, 2) + Math.pow(point.y - y, 2)
          );
          
          if (distance < 0.03) {
            selectedPoint = point;
            pointClicked = true;
            break;
          }
        }
        
        // 固定点（左下と右上）は動かせない
        if (selectedPoint === points[0] && points[0].x === 0 && points[0].y === 0) {
          selectedPoint = null;
          return;
        }
        
        if (selectedPoint === points[points.length - 1] && 
            points[points.length - 1].x === 1 && points[points.length - 1].y === 1) {
          selectedPoint = null;
          return;
        }
        
        // 新しい点を追加
        if (!pointClicked) {
          const newPoint = { x: x, y: y };
          points.push(newPoint);
          selectedPoint = newPoint;
          
          // ポイントをx座標でソート
          points.sort((a, b) => a.x - b.x);
        }
        
        drawToneCurve();
        applyToneCurve();
      }
      
      function handleCanvasMouseMove(e) {
        if (!selectedPoint) return;
        
        const rect = toneCurveCanvas.getBoundingClientRect();
        const x = (e.clientX - rect.left) / toneCurveCanvas.width;
        const y = 1 - (e.clientY - rect.top) / toneCurveCanvas.height;
        
        // 左右の境界を超えないようにする
        selectedPoint.x = Math.max(0, Math.min(1, x));
        selectedPoint.y = Math.max(0, Math.min(1, y));
        
        drawToneCurve();
        applyToneCurve();
      }
      
      // トーンカーブのリセット
      function resetCurve() {
        points = [
          { x: 0, y: 0 },
          { x: 1, y: 1 }
        ];
        
        drawToneCurve();
        applyToneCurve();
      }
      
      // 画像のダウンロード
      function downloadImage() {
        if (!processedImage) return;
        
        // 一時キャンバスを作成
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = originalImage.width;
        tempCanvas.height = originalImage.height;
        
        // 中央の画像部分だけを切り出す
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.putImageData(
          previewCtx.getImageData(
            originalImage.offsetX,
            originalImage.offsetY,
            originalImage.width,
            originalImage.height
          ),
          0, 0
        );
        
        // ダウンロードリンクを作成
        const link = document.createElement('a');
        link.download = 'edited-image.png';
        link.href = tempCanvas.toDataURL('image/png');
        link.click();
      }
      
      // 初期トーンカーブを描画
      drawToneCurve();
    });
  </script>
</body>
</html>